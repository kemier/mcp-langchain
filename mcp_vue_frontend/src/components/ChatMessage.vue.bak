<script setup>
import { ref, computed, onMounted, watch } from 'vue';
import hljs from 'highlight.js/lib/core';
import 'highlight.js/styles/atom-one-dark.css';

// Import languages
import python from 'highlight.js/lib/languages/python';
import javascript from 'highlight.js/lib/languages/javascript';
import typescript from 'highlight.js/lib/languages/typescript';
import json from 'highlight.js/lib/languages/json';
import bash from 'highlight.js/lib/languages/bash';
import xml from 'highlight.js/lib/languages/xml';
import cpp from 'highlight.js/lib/languages/cpp';
import c from 'highlight.js/lib/languages/c';
import go from 'highlight.js/lib/languages/go';
import rust from 'highlight.js/lib/languages/rust';
import ini from 'highlight.js/lib/languages/ini';
import yaml from 'highlight.js/lib/languages/yaml';

// Register languages
hljs.registerLanguage('python', python);
hljs.registerLanguage('javascript', javascript);
hljs.registerLanguage('typescript', typescript);
hljs.registerLanguage('json', json);
hljs.registerLanguage('bash', bash);
hljs.registerLanguage('html', xml);
hljs.registerLanguage('xml', xml);
hljs.registerLanguage('cpp', cpp);
hljs.registerLanguage('c', c);
hljs.registerLanguage('go', go);
hljs.registerLanguage('rust', rust);
hljs.registerLanguage('ini', ini);
hljs.registerLanguage('toml', ini);
hljs.registerLanguage('yaml', yaml);
hljs.registerLanguage('yml', yaml);

const props = defineProps({
  message: {
    type: Object,
    required: true,
    default: () => ({
      text: '',
      sender: 'agent',
      isStreaming: false,
      isGenerating: false
    })
  }
});

const emit = defineEmits(['suggestion-click', 'action-click']);

const parsedBlocks = ref([]);
const copiedStates = ref({}); // Track which code blocks have been copied

const currentLanguage = ref(null); // Define currentLanguage
const processedText = ref(''); // Define processedText, was also missing from earlier snippet
const codeBlocks = ref([]); // Define codeBlocks, was also missing from earlier snippet

// Function to send debug logs to the backend (TEMPORARY FOR DEBUGGING)
async function sendDebugLogToServer(logEntry) {
  if (!window.enableStreamDebugLogging) return;
  try {
    await fetch('/api/debug-log', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(logEntry),
    });
  } catch (error) {
    console.error('[Frontend Logger] Failed to send log to server:', error);
  }
}

// Method to get highlighted HTML for a code block
function getHighlightedCodeHtml(code, languageHint) {
  if (!code) return '';
  try {
    // Normalize common language hints
    const lang = languageHint ? languageHint.toLowerCase() : '';
    let actualLangToUse = lang;

    // Aliases or common misnamings
    if (lang === 'js') actualLangToUse = 'javascript';
    if (lang === 'ts') actualLangToUse = 'typescript';
    if (lang === 'shell' || lang === 'sh') actualLangToUse = 'bash';
    if (lang === 'zsh' || lang === 'cmd' || lang === 'terminal') actualLangToUse = 'bash';
    if (lang === 'html5') actualLangToUse = 'html';
    if (lang === 'c++') actualLangToUse = 'cpp';
    if (lang === 'c') actualLangToUse = 'c';
    if (lang === 'golang') actualLangToUse = 'go';
    if (lang === 'rs') actualLangToUse = 'rust';
    if (lang === 'toml' || lang === 'cargo.toml') actualLangToUse = 'toml';
    if (lang === 'yml') actualLangToUse = 'yaml';
    if (lang === 'markup') actualLangToUse = 'xml';

    if (actualLangToUse && hljs.getLanguage(actualLangToUse)) {
      return hljs.highlight(code, { language: actualLangToUse, ignoreIllegals: true }).value;
    }
    // If no hint, hint is not recognized, or it's an empty string, try auto-detection with registered languages
    const autoResult = hljs.highlightAuto(code, Object.keys(hljs.listLanguages()));
    // console.log(`[HLJS-DEBUG] Auto-detected: ${autoResult.language}, relevance: ${autoResult.relevance}`); // Keep this as console for now, or decide if it also needs server logging
    return autoResult.value;
  } catch (e) {
    console.error("[HLJS-DEBUG] Error highlighting code:", e, "Language hint:", languageHint, "Code:", code.substring(0, 50) + "...");
    // Fallback: return code as plain text, escaped, to be safe with v-html
    const escapeHtml = (unsafe) => {
        return unsafe
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
    }
    return escapeHtml(code);
  }
}

// More comprehensive regex to extract code blocks
// This handles triple backtick blocks with language specification
function extractCodeBlocks(text) {
  // If the message is empty or undefined, return empty array
  if (!text) return [];
  
  const result = [];
  let lastIndex = 0;
  
  // Check for loading/generating state first - but ONLY if is still streaming
  if (props.message.isStreaming && props.message.isGenerating && (text.includes("Generating response") || !text.trim())) {
    return [{
      type: 'code', // Treat as code for consistent rendering in <pre><code>
      language: 'plaintext', // Will be rendered as plain text
      content: 'Generating response...',
      isGenerating: true
    }];
  }
  
  // Check for "Agent is thinking..." message
  if (text.includes("Agent is thinking") || text.includes("Agent is processing")) {
    return [{
      type: 'text',
      content: text,
      isThinking: true
    }];
  }
  
  // Check for "Processing your request..." message which may appear at the beginning
  if (text.startsWith("Processing your request...")) {
    const actualContent = text.replace("Processing your request...", "").trim();
    if (actualContent) {
      return extractCodeBlocks(actualContent);
    }
    return [{
      type: 'text',
      content: text,
      isThinking: true
    }];
  }
  
  // MAJOR FIX: Better detection of conversational text vs code
  // If there are no code block markers (```) AND the text appears to be natural language,
  // just return it as plain text without further processing
  if (!text.includes('```')) {
    // Define characteristics of natural language
    const hasNaturalLanguageFeatures = 
      // Multiple sentences with proper punctuation and capitalization
      text.match(/[.!?]\s+[A-Z]/g) || 
      // Question marks in text but not at the end of a line of code
      (text.includes('?') && !text.match(/\w+\?$/m)) ||
      // Multiple paragraphs with proper sentences
      (text.split('\n\n').length > 1 && text.match(/[A-Z][^.!?]+[.!?]/g)) ||
      // More than 3 commas (likely prose, not code)
      (text.match(/,/g) && text.match(/,/g).length > 3) ||
      // Conversational phrases
      (text.match(/\b(I|you|we|they|he|she|is|are|was|were|have|had|would|could|should|might|will|can)\b/gi) &&
       text.match(/\b(I|you|we|they|he|she|is|are|was|were|have|had|would|could|should|might|will|can)\b/gi).length > 3);
      
    // Check that it DOESN'T have code-like features
    const hasNoCodeFeatures = 
      !text.includes('{') && 
      !text.includes('}') && 
      !text.includes('def ') && 
      !text.includes('class ') && 
      !text.includes('function ') && 
      !text.includes('import ') && 
      !text.includes('from ') && 
      !text.includes('const ') && 
      !text.includes('let ') && 
      !text.includes('var ');
      
    // If it looks like plain conversational text, return it directly
    if (hasNaturalLanguageFeatures && hasNoCodeFeatures) {
      return [{
        type: 'text',
        content: text
      }];
    }
    
    // Additional check - if it's a short message with any punctuation, likely plain text
    if (text.length < 100 && text.match(/[.,!?;]/) && !text.match(/[\{\}=]/)) {
      return [{
        type: 'text',
        content: text
      }];
    }
  }
  
  // Quick check - if the text doesn't contain ``` backticks, and doesn't look like code,
  // return it as plain text immediately to avoid unnecessary processing
  if (!text.includes('```')) {
    // IMPORTANT FIX: Check if the text lacks code characteristics before returning as text
    const looksLikeCode = 
      (text.includes('{') && text.includes('}')) || 
      (text.includes('def ') && text.includes(':')) || 
      (text.includes('import ') && text.includes('from ')) ||
      (text.includes('function') && text.includes('return')) ||
      (text.includes('#include') || text.includes('int main('));
      
    // If it doesn't look like code, return it as plain text
    if (!looksLikeCode) {
      return [{
        type: 'text',
        content: text
      }];
    }
  }
  
  // For streaming messages with isStreaming flag, add visual indicator
  if (props.message.isStreaming) {
    if (window.enableStreamDebugLogging) sendDebugLogToServer({ timestamp: new Date().toISOString(), source: 'extractCodeBlocks', event: 'streaming_active', details: { textLength: text.length, currentTextChunk: text.substring(0,100)+'...'} });
    
    const backtickMatches = text.split('```');
    if (window.enableStreamDebugLogging) sendDebugLogToServer({ timestamp: new Date().toISOString(), source: 'extractCodeBlocks', event: 'backtick_split', details: { segmentCount: backtickMatches.length } });
        
    const numBackticks = backtickMatches.length - 1;
    const hasCompleteCodeBlocksBySegments = backtickMatches.length > 1 && backtickMatches.length % 2 === 1; // Odd segments for even backticks
    const hasIncompleteCodeBlockBySegments = backtickMatches.length > 0 && backtickMatches.length % 2 === 0; // Even segments for odd backticks

    if (window.enableStreamDebugLogging) sendDebugLogToServer({ 
        timestamp: new Date().toISOString(), 
        source: 'extractCodeBlocks', 
        event: 'code_block_analysis', 
        details: { 
            numBackticks, 
            hasCompleteCodeBlocksBySegments, 
            hasIncompleteCodeBlockBySegments 
        }
    });
    
    if (hasIncompleteCodeBlockBySegments) {
      if (window.enableStreamDebugLogging) sendDebugLogToServer({ timestamp: new Date().toISOString(), source: 'extractCodeBlocks', event: 'incomplete_block_detected', details: { segmentCount: backtickMatches.length } });
      const parts = backtickMatches;
      const preCodePart = parts.slice(0, -1).join('```');
      const codeStartPart = parts[parts.length - 1];
      
      if (window.enableStreamDebugLogging) sendDebugLogToServer({ 
          timestamp: new Date().toISOString(), 
          source: 'extractCodeBlocks', 
          event: 'incomplete_block_parts', 
          details: { 
              preCodePartSnippet: preCodePart.substring(0,100)+'...', 
              codeStartPartSnippet: codeStartPart.substring(0,100)+'...' 
          }
      });
      
      // --- START REPLACEMENT FOR LINES 194-233 ---
      // Helper to normalize language names
      const normalizeStreamingLang = (lang) => {
        if (!lang) return 'plaintext';
        const l = lang.toLowerCase();
        if (l === 'js') return 'javascript';
        if (l === 'ts') return 'typescript';
        if (l === 'py') return 'python';
        if (l === 'c++') return 'cpp';
        if (l === 'sh' || l === 'shell' || l === 'bash' || l === 'zsh') return 'bash';
        if (l === 'yml') return 'yaml';
        if (l === 'rs') return 'rust';
        if (l === 'golang') return 'go';
        if (l === 'markup') return 'xml';
        return l; 
      };

      const streamingLangIdentifiers = ['c', 'cpp', 'c++', 'go', 'golang', 'rust', 'rs', 'javascript', 'js', 'python', 'py', 'xml', 'yaml', 'yml', 'json', 'toml', 'bash', 'sh', 'shell', 'zsh', 'typescript', 'ts', 'markup'];

      let codeLanguage = 'plaintext'; 
      let cleanedContent = codeStartPart; // Default to full part, updated if lang is extracted
      let langExtractionSuccessful = false;

      const trimmedCodeStart = codeStartPart.trimStart(); // Trim leading newlines/spaces
      const firstNewlineInTrimmed = trimmedCodeStart.indexOf('\n');

      if (firstNewlineInTrimmed > -1) { // Check if there's a newline after potential lang
        const firstLineCandidate = trimmedCodeStart.substring(0, firstNewlineInTrimmed).trim().toLowerCase();
        if (streamingLangIdentifiers.includes(firstLineCandidate)) {
          codeLanguage = normalizeStreamingLang(firstLineCandidate);
          cleanedContent = trimmedCodeStart.substring(firstNewlineInTrimmed + 1);
          langExtractionSuccessful = true;
        }
      }

      if (!langExtractionSuccessful) { // If not "lang\ncontent", check if whole thing is just a lang name
        const trimmedFullCodeStart = codeStartPart.trim().toLowerCase(); // Trim both ends for this check
        if (streamingLangIdentifiers.includes(trimmedFullCodeStart)) {
          codeLanguage = normalizeStreamingLang(trimmedFullCodeStart);
          cleanedContent = ''; // If it's only a language name, content is initially empty
          langExtractionSuccessful = true;
        }
      }
      // If langExtractionSuccessful is still false, codeLanguage remains 'plaintext'
      // and cleanedContent remains the original codeStartPart. 
      // This allows subsequent heuristics (from line 236 onwards) to run if needed.
      // --- END REPLACEMENT FOR LINES 194-233 ---
      
      // Check if the first line after the initial language line is just a language name by itself
      if (cleanedContent && (codeLanguage === 'plaintext' || !codeLanguage)) {
        const contentFirstLineEnd = cleanedContent.indexOf('\n');
        if (contentFirstLineEnd > 0) {
          const possibleLang = cleanedContent.substring(0, contentFirstLineEnd).trim().toLowerCase();
          const validLangs = ['python', 'py', 'javascript', 'js', 'typescript', 'ts', 'c', 'cpp', 'c++',
                              'rust', 'rs', 'go', 'golang', 'java', 'bash', 'sh', 'shell', 'zsh', 
                              'toml', 'yaml', 'yml', 'json', 'xml', 'html', 'css', 'sql'];
          
          if (validLangs.includes(possibleLang)) {
            // If first line is just a language name, use it and remove that line
            codeLanguage = possibleLang;
            cleanedContent = cleanedContent.substring(contentFirstLineEnd + 1);
            
            // Normalize language aliases
            if (codeLanguage === 'py') codeLanguage = 'python';
            if (codeLanguage === 'js') codeLanguage = 'javascript';
            if (codeLanguage === 'ts') codeLanguage = 'typescript';
            if (codeLanguage === 'c++') codeLanguage = 'cpp';
            if (codeLanguage === 'rs') codeLanguage = 'rust';
            if (codeLanguage === 'golang') codeLanguage = 'go';
            if (codeLanguage === 'sh' || codeLanguage === 'shell' || codeLanguage === 'zsh') codeLanguage = 'bash';
            if (codeLanguage === 'yml') codeLanguage = 'yaml';
          }
        }
      }
      
      // Get potential code content excluding language for fallback detection
      const potentialCode = cleanedContent;
      
      // Fall back to content-based detection only if no specific language was found
      if (codeLanguage === 'plaintext' || !codeLanguage) {
        // First check if the content itself starts with a language identifier on its own line
        const contentFirstLineEnd = cleanedContent.indexOf('\n');
        if (contentFirstLineEnd > 0) {
          const firstLine = cleanedContent.substring(0, contentFirstLineEnd).trim().toLowerCase();
          const validLangs = ['python', 'py', 'javascript', 'js', 'typescript', 'ts', 'c', 'cpp', 'c++',
                             'rust', 'rs', 'go', 'golang', 'java', 'bash', 'sh', 'shell', 'zsh', 
                             'toml', 'yaml', 'yml', 'json', 'xml', 'html', 'css', 'sql'];
          
          if (validLangs.includes(firstLine)) {
            codeLanguage = firstLine;
            cleanedContent = cleanedContent.substring(contentFirstLineEnd + 1).trim();
            
            // Normalize language aliases
            if (codeLanguage === 'py') codeLanguage = 'python';
            if (codeLanguage === 'js') codeLanguage = 'javascript';
            if (codeLanguage === 'ts') codeLanguage = 'typescript';
            if (codeLanguage === 'c++') codeLanguage = 'cpp';
            if (codeLanguage === 'rs') codeLanguage = 'rust';
            if (codeLanguage === 'golang') codeLanguage = 'go';
            if (codeLanguage === 'sh' || codeLanguage === 'shell' || codeLanguage === 'zsh') codeLanguage = 'bash';
            if (codeLanguage === 'yml') codeLanguage = 'yaml';
          }
        }
        
        // If no language identified from first line, try pattern matching
        if (codeLanguage === 'plaintext' || !codeLanguage) {
          // Content-based detection for common patterns
          if (cleanedContent.includes('#include <stdio.h>')) codeLanguage = 'c';
          // Rust check before C++ - MODIFIED Rust Regex
          else if (cleanedContent.includes('fn main') || cleanedContent.includes('use std::') || cleanedContent.includes('mod ') || cleanedContent.includes('crate::') ||
                  cleanedContent.match(/\b(async\s+fn|impl|struct|enum|trait|let\s+mut|tokio::|Result<|Ok\(|Err\()/)) {
            codeLanguage = 'rust';
          }
          // C++ check
          else if (cleanedContent.includes('#include <iostream>') || cleanedContent.includes('std::')) {
            codeLanguage = 'cpp';
          }
          // Go check (original position after C++)
          else if (cleanedContent.includes('package main') || cleanedContent.includes('func ')) {
            codeLanguage = 'go';
          }
          // More specific Python detection to avoid false positives with bulleted lists
          else if ((cleanedContent.match(/^import\s+[\w\.]+|^from\s+[\w\.]+\s+import|^def\s+\w+\s*\(|^class\s+\w+/) || 
                    cleanedContent.includes('if __name__ == "__main__"')) && 
                    // Ensure it's not just a bulleted list with Python-like formatting
                    !(cleanedContent.match(/^[-–*]\s+/) && cleanedContent.match(/\w+:/g) && !cleanedContent.includes('def '))) {
            codeLanguage = 'python';
          }
          else if (cleanedContent.includes('function') || cleanedContent.match(/const|let|var\s+\w+\s*=/)) codeLanguage = 'javascript';
          else if (cleanedContent.match(/^<.+>/) || cleanedContent.includes('<?xml')) codeLanguage = 'xml';
          else if (cleanedContent.match(/^[\w-]+:\s*/) || cleanedContent.match(/^\s*-\s+[\w-]+:/)) codeLanguage = 'yaml';
          // Corrected: json check
          else if (cleanedContent.match(/^\s*[\{\[]/) && cleanedContent.includes(':')) codeLanguage = 'json';
          else if (cleanedContent.includes('[') && cleanedContent.includes('=')) codeLanguage = 'toml';
          // Extra detection for shell commands
          else if (cleanedContent.match(/^(cargo|npm|yarn|pip|go|gcc|make|cmake|sudo|apt-get|yum)\s/) || 
                   cleanedContent.includes('#!/bin/') || 
                   cleanedContent.match(/\$\s/)) {
            codeLanguage = 'bash';
          }
        }
        
        // Detect if this is likely a regular text message with bullet points
        if ((cleanedContent.match(/^[-–*]\s+/) || cleanedContent.match(/^\d+\.\s+/)) && 
            (cleanedContent.match(/\w+[,.?!]/) || cleanedContent.includes('\n-'))) {
          codeLanguage = 'plaintext'; // Force plaintext for bulleted/numbered lists
        }
      }
      
      // Only process previous content if it's not empty
      const result = [];
      if (preCodePart && preCodePart.trim()) {
        // Process all complete code blocks and text before the incomplete block
        const preBlocks = extractCompleteBlocks(preCodePart);
        result.push(...preBlocks);
      }
      
      // Add the incomplete code block
      result.push({
        type: 'code',
        language: codeLanguage || 'plaintext',
        content: cleanedContent || '',
        isGenerating: true, // Always show generating for incomplete blocks
        isPartial: true
      });
      
      if (window.enableStreamDebugLogging) sendDebugLogToServer({ 
          timestamp: new Date().toISOString(), 
          source: 'extractCodeBlocks', 
          event: 'returning_from_incomplete_block', 
          details: { 
              blockCount: result.length, 
              lastBlockLang: codeLanguage 
          }
      });
      return result;
    } else if (hasCompleteCodeBlocksBySegments) {
      if (window.enableStreamDebugLogging) sendDebugLogToServer({ timestamp: new Date().toISOString(), source: 'extractCodeBlocks', event: 'complete_blocks_detected_streaming', details: {} });
    } else {
      if (window.enableStreamDebugLogging) sendDebugLogToServer({ timestamp: new Date().toISOString(), source: 'extractCodeBlocks', event: 'no_significant_backticks_streaming', details: {} });
    }
  }
  
  const suggestionRegex = /\[(.*?)\]/g;  // Fixed: removed extra escapes
  let suggestionMatch;
  
  while ((suggestionMatch = suggestionRegex.exec(text)) !== null) {
    if (suggestionMatch.index > lastIndex) {
      result.push({
        type: 'text',
        content: text.substring(lastIndex, suggestionMatch.index)
      });
    }
    result.push({
      type: 'suggestion',
      text: suggestionMatch[1].trim()
    });
    lastIndex = suggestionMatch.index + suggestionMatch[0].length;
  }
  
  const imageRegex = /!\[(.*?)\]\((https?:\/\/[^)\s]+)\)/g;  // Fixed: removed extra escapes
  let imageMatch;
  
  while ((imageMatch = imageRegex.exec(text)) !== null) {
    if (imageMatch.index > lastIndex) {
      result.push({
        type: 'text',
        content: text.substring(lastIndex, imageMatch.index)
      });
    }
    result.push({
      type: 'image',
      alt: imageMatch[1],
      url: imageMatch[2],
    });
    lastIndex = imageMatch.index + imageMatch[0].length;
  }
  
  // Regex for standard markdown code blocks: ```lang\\ncode```
  // Handles optional language, and captures code content correctly.
  const codeBlockRegex = /```([\w#+-]*)([\s\S]*?)```/g;
  let match;
  
  // Define these helpers here if they are not in a scope accessible to this loop
  // or ensure they are passed/defined at a higher scope within extractCodeBlocks.
  // For this edit, we'll assume they need to be available here.
  const normalizeLangTag = (lang) => {
    if (!lang) return 'plaintext';
    const l = lang.toLowerCase().trim();
    if (l === 'js') return 'javascript';
    if (l === 'ts') return 'typescript';
    if (l === 'py') return 'python';
    if (l === 'c++') return 'cpp';
    if (l === 'sh' || l === 'shell' || l === 'bash' || l === 'zsh') return 'bash';
    if (l === 'yml') return 'yaml';
    if (l === 'rs') return 'rust';
    if (l === 'golang') return 'go';
    return l || 'plaintext';
  };
  
  // Process code blocks
  while ((match = codeBlockRegex.exec(text)) !== null) {
    if (match.index > lastIndex) {
      // Add text before this code block
      const textSegment = text.substring(lastIndex, match.index);
      if (textSegment.trim()) {
        result.push({
          type: 'text',
          content: textSegment
        });
      }
    }
    
    // Extract language and content
    let [, langTag, codeContent] = match;
    
    // 处理可能存在的换行符转义问题
    if (codeContent && typeof codeContent === 'string') {
      // 确保所有的 \n 转义序列被替换为实际的换行符
      codeContent = codeContent.replace(/\\n/g, '\n');
    }
    
    // If langTag has content, check if it actually contains a newline
    if (langTag && langTag.includes('\n')) {
      // This means the langTag capture group incorrectly grabbed the first line of code
      // Move everything after the newline to codeContent
      const newlinePos = langTag.indexOf('\n');
      const actualLang = langTag.substring(0, newlinePos).trim();
      const firstCodeLine = langTag.substring(newlinePos + 1);
      langTag = actualLang;
      codeContent = firstCodeLine + (codeContent ? '\n' + codeContent : '');
    }
    
    // Normalize langTag (remove leading newline if present)
    if (langTag && langTag.startsWith('\n')) {
      langTag = langTag.substring(1).trim();
    }
    
    // Normalize codeContent
    if (codeContent && codeContent.startsWith('\n')) {
      codeContent = codeContent.substring(1);
    }
    
    // Identify language
    const language = normalizeLangTag(langTag);
    
    // Add code block
    result.push({
      type: 'code',
      language,
      content: codeContent || '',
      isGenerating: false,
      isPartial: false
    });
    
    lastIndex = match.index + match[0].length;
  }
  
  const annotationRegex = /:::\s*(info|warning|error|success)\s*\n([\s\S]*?):::/g;
  let annotationMatch;
  
  while ((annotationMatch = annotationRegex.exec(text)) !== null) {
    if (annotationMatch.index > lastIndex) {
      result.push({
        type: 'text',
        content: text.substring(lastIndex, annotationMatch.index)
      });
    }
    result.push({
      type: 'annotation',
      annotationType: annotationMatch[1],
      content: annotationMatch[2].trim()
    });
    lastIndex = annotationMatch.index + annotationMatch[0].length;
  }
  
  const actionRegex = /\[action:(.*?):(.*?)\]/g;
  let actionMatch;
  
  while ((actionMatch = actionRegex.exec(text)) !== null) {
    if (actionMatch.index > lastIndex) {
      result.push({
        type: 'text',
        content: text.substring(lastIndex, actionMatch.index)
      });
    }
    
    // Add null checks before using trim()
    const label = actionMatch[1] ? actionMatch[1].trim() : '';
    const id = actionMatch[2] ? actionMatch[2].trim() : '';
    
    if (label && id) {
      result.push({
        type: 'action',
        label: label,
        id: id
      });
    } else {
      // If the match is invalid, just treat it as text
      result.push({
        type: 'text',
        content: actionMatch[0]
      });
    }
    
    lastIndex = actionMatch.index + actionMatch[0].length;
  }
  
  if (lastIndex < text.length) {
    result.push({
      type: 'text',
      content: text.substring(lastIndex)
    });
  }
  
  // If, after all parsing, result is empty but there was original text, treat as plain text.
  if (result.length === 0 && text && text.trim().length > 0) {
    result.push({ type: 'text', content: text });
  }

  // Additional check for unclosed code blocks that might have been missed
  // This is a safety measure in case streaming is active but the block is incomplete
  if (props.message.isStreaming) {
    const segments = text.split('```');
    if (segments.length > 1 && segments.length % 2 === 0) {
      // We have an unclosed code block
      const lastSegment = segments[segments.length - 1];
      
      // Only add if we haven't already processed up to this point
      if (lastIndex < text.lastIndexOf('```')) {
        const languageMatch = /^([\w#+-]*)\n/.exec(lastSegment);
        let language = 'plaintext';
        let content = lastSegment;
        
        if (languageMatch) {
          language = languageMatch[1] || 'plaintext';
          content = lastSegment.substring(languageMatch[0].length);
        }
        
        // Handle specific languages
        if (language.toLowerCase() === 'c') language = 'c';
        if (language.toLowerCase() === 'javascript' || language.toLowerCase() === 'js') language = 'javascript';
        
        // Add the incomplete code block
        result.push({
          type: 'code',
          language: language,
          content: content,
          isGenerating: true, // Mark as still generating
          isPartial: true     // Mark as partial
        });
      }
    }
  }

  return result;
}

// Enhanced text formatting with markdown-like features
function formatText(text) {
  if (!text) return '';
  
  // Log content being rendered for debugging
  console.log("[CHAT-UI-RENDER] Rendering content:", 
    text.length > 30 ? text.substring(0, 30) + '...' : text,
    "Length:", text.length);
    
  // Clean up the text before formatting
  let cleanedText = text;
  
  // First, try to handle complete JSON objects
  if (cleanedText.trim().startsWith('{') && cleanedText.trim().endsWith('}')) {
    try {
      const jsonObj = JSON.parse(cleanedText);
      if (jsonObj.content !== undefined) {
        cleanedText = jsonObj.content;
        console.log("[CHAT-UI-RENDER] Extracted content from JSON object");
      }
    } catch (e) {
      // Not valid JSON, attempt regex cleanup next
      console.log("[CHAT-UI-RENDER] Text looks like JSON but failed to parse");
    }
  }
  
  // Use regular expressions to strip JSON-like structures even if JSON.parse failed
  // First try: {"content": "actual content here"}
  let contentMatch = cleanedText.match(/^\s*\{\s*"content"\s*:\s*"(.+)"\s*\}\s*$/s);
  if (contentMatch && contentMatch[1]) {
    cleanedText = contentMatch[1];
    // Unescape escaped quotes
    cleanedText = cleanedText.replace(/\\"/g, '"');
    console.log("[CHAT-UI-RENDER] Extracted content via regex (1)");
  }
  
  // Second try: {"content": 'actual content here'}
  contentMatch = cleanedText.match(/^\s*\{\s*"content"\s*:\s*'(.+)'\s*\}\s*$/s);
  if (contentMatch && contentMatch[1]) {
    cleanedText = contentMatch[1];
    // Unescape escaped quotes
    cleanedText = cleanedText.replace(/\\'/g, "'");
    console.log("[CHAT-UI-RENDER] Extracted content via regex (2)");
  }
  
  // Third try: {"status":"done","content":"actual content here"}
  contentMatch = cleanedText.match(/^\s*\{\s*"status"\s*:\s*"[^"]*"\s*,\s*"content"\s*:\s*"(.+)"\s*\}\s*$/s);
  if (contentMatch && contentMatch[1]) {
    cleanedText = contentMatch[1];
    // Unescape escaped quotes
    cleanedText = cleanedText.replace(/\\"/g, '"');
    console.log("[CHAT-UI-RENDER] Extracted content from status JSON via regex");
  }
  
  // Remove any remaining content prefix
  cleanedText = cleanedText.replace(/^content:\s*/i, '');
  
  // Remove trailing metadata or suffix patterns
  cleanedText = cleanedText.replace(/\[end\s+of\s+content\]$/i, '');
  cleanedText = cleanedText.replace(/\[end\]$/i, '');
  cleanedText = cleanedText.replace(/\[finished\]$/i, '');
  cleanedText = cleanedText.replace(/\[complete\]$/i, '');
  
  // First, ensure newlines are properly preserved by converting them to <br> tags
  let formattedText = cleanedText.replace(/\n/g, '<br>');
  
  // Handle inline code with backticks: `code`
  formattedText = formattedText.replace(
    /`([^`]+)`/g,
    (match, code) => `<code class="inline-code">${code}</code>`
  );
  
  // Handle bold text with asterisks: **bold text**
  formattedText = formattedText.replace(
    /\*\*([^*]+)\*\*/g,
    (match, bold) => `<strong>${bold}</strong>`
  );
  
  // Handle italic text with underscores: _italic text_
  formattedText = formattedText.replace(
    /\_([^_]+)\_/g,
    (match, italic) => `<em>${italic}</em>`
  );
  
  // Handle links: [link text](url)
  formattedText = formattedText.replace(
    /\[([^\]]+)\]\(([^)]+)\)/g,
    (match, text, url) => `<a href="${url}" target="_blank" rel="noopener noreferrer">${text}</a>`
  );
  
  // Handle bullet lists - need to handle the <br> tags we inserted
  formattedText = formattedText.replace(
    /(<br>|^)[\s]*[-*][\s](.+?)(?=<br>|$)/g,
    (match, br, listItem) => `${br}<li>${listItem}</li>`
  );
  
  // Wrap adjacent list items in <ul> tags
  formattedText = formattedText.replace(
    /(<li>.+<\/li>)+/g,
    (match) => `<ul class="markdown-list">${match}</ul>`
  );
  
  // Don't replace newlines with <br> tags since we already did that at the start
  
  return formattedText;
}

// Process the message immediately when the component is created
// and also watch for changes to the message
function processMessage() {
  try {
    console.log("[CHAT-UI-PROCESS] Processing message:", 
      props.message.text ? 
        (props.message.text.length > 30 ? props.message.text.substring(0, 30) + '...' : props.message.text) 
        : 'EMPTY',
      "Length:", props.message.text?.length || 0);
    
    // If message text is empty and we are in a generating/streaming state for an agent message,
    // set parsedBlocks to empty. The thinking indicator in the template will show.
    if ((!props.message?.text || props.message?.text === '') && 
        (props.message?.isGenerating || props.message?.isStreaming) && 
        props.message?.sender === 'agent') {
      parsedBlocks.value = []; // Empty blocks, will show thinking indicator
      return;
    }
    
    // Strip away any initial "Processing your request..." text
    let textToProcess = props.message.text || '';
    if (textToProcess.startsWith("Processing your request...")) {
      textToProcess = textToProcess.replace("Processing your request...", "").trim();
    }
    
    parsedBlocks.value = extractCodeBlocks(textToProcess);
  } catch (e) {
    console.error('[CHAT-UI-PROCESS] Error processing message:', e);
    parsedBlocks.value = [{
      type: 'text',
      content: props.message.text || 'Error processing message'
    }];
  }
}

// Process the message immediately when the component is created
// and also watch for changes to the message
watch(() => props.message, (newMessage, oldMessage) => {
  if (newMessage !== oldMessage) {
    console.log('[CHAT-UI-WATCH] Message changed:', 
      newMessage?.text ? 
        (newMessage.text.length > 30 ? newMessage.text.substring(0, 30) + '...' : newMessage.text) 
        : 'EMPTY',
      "Length:", newMessage?.text?.length || 0);
    processMessage();
  }
}, { immediate: true });

// Update the watch function for better message handling
// Watch for ANY changes to the entire message object (deep)
watch(() => props.message, (newMessage, oldMessage) => {
  if (window.enableStreamDebugLogging) sendDebugLogToServer({ 
      timestamp: new Date().toISOString(), 
      source: 'watch_props.message', 
      event: 'triggered', 
      details: { 
          messageId: newMessage.id, 
          newTextSnippet: newMessage.text ? newMessage.text.substring(0,30)+'...' : '(empty)', 
          newIsStreaming: newMessage.isStreaming,
          oldTextSnippet: oldMessage ? (oldMessage.text ? oldMessage.text.substring(0,30)+'...' : '(empty)') : '(no old msg)',
          oldIsStreaming: oldMessage?.isStreaming
      }
  });
  
  // Immediately process the message regardless of what changed
  console.log(`[CHAT-MSG-COMPONENT] Processing message due to complete object change: ID=${newMessage.id}, Text length=${newMessage.text?.length || 0}`);
  processMessage();
}, { deep: true, immediate: true });

// Add a specific watch for just the text property for more granular updates
watch(() => props.message.text, (newText, oldText) => {
  if (newText !== oldText) {
    console.log(`[CHAT-MSG-COMPONENT] Message text updated: Length=${newText?.length || 0}, Changed=${newText !== oldText}`);
    // Force immediate re-processing
    processMessage();
  }
}, { immediate: true });

// Add a specific watch for streaming state changes
watch(() => props.message.isStreaming, (isStreaming, wasStreaming) => {
  if (isStreaming !== wasStreaming) {
    console.log(`[CHAT-MSG-COMPONENT] Streaming state changed: ${wasStreaming} → ${isStreaming}`);
    // Re-process to update visual indicators
    processMessage();
  }
});

// Is this a thinking/loading message?
const isThinking = computed(() => {
  return (
    props.message.isGenerating || 
    !props.message.text || 
    props.message.text === '' ||
    (props.message.text && 
      (props.message.text.includes('Thinking') || 
       props.message.text.includes('Processing')))
  );
});

// Handle suggestion click - emit event up to parent with the suggestion text
function handleSuggestionClick(suggestion) {
  emit('suggestion-click', suggestion);
}

// Handle action button click
function handleActionClick(actionId) {
  emit('action-click', actionId);
}

// Function to preprocess content before rendering
function preprocessContent(text) {
  if (!text) return '';
  
  // Helper regex patterns
  const jsKeywordsPattern = /\b(function|const|let|var|=>)/;
  // Keywords more specific to JS or less likely in typical Rust snippets that might contain `let` by chance
  const strongJsKeywordsPattern = /\b(function|var|=>|document\.|window\.|console\.log)/;
  // Keywords strongly indicative of Rust, to avoid misclassifying Rust as JS due to `let` or `const`
  const strongRustKeywordsPattern = /\b(fn|struct|enum|impl|mod|crate|use std|let mut|match|loop|async fn|tokio::)/;
  
  // Check if this looks like JavaScript code without proper formatting (all on one line)
  if ((text.includes('function ') && (text.includes('return ') || text.includes('{'))) || 
      (text.includes('const ') || text.includes('let ') || text.includes('var ')) && 
      text.includes('=') && !text.includes('\n')) {
    // Format JavaScript code by adding proper newlines and indentation
    return text
      .replace(/function\s+([^(]+)\(/g, 'function $1(')
      .replace(/\)\s*{/g, ') {\n  ')
      .replace(/for\s+\([^)]+\)\s*{/g, match => match.replace('{', '{\n  '))
      .replace(/if\s+\([^)]+\)\s*{/g, match => match.replace('{', '{\n  '))
      .replace(/else\s*{/g, 'else {\n  ')
      .replace(/return\s+/g, 'return ')
      .replace(/const\s+([^=]+)=/g, 'const $1 = ')
      .replace(/let\s+([^=]+)=/g, 'let $1 = ')
      .replace(/var\s+([^=]+)=/g, 'var $1 = ')
      .replace(/;\s*(?=[a-zA-Z])/g, ';\n');
  }
  
  // Check if this looks like Python code without proper formatting (all on one line)
  if (text.includes('def ') && text.includes('return ') && !text.includes('\n')) {
    // Format Python code by adding proper newlines and indentation
    return text
      .replace(/def\s+([^(]+)\(/g, 'def $1(')
      .replace(/\):/g, '):\n    ')
      .replace(/for\s+([^:]+):/g, 'for $1:\n    ')
      .replace(/if\s+([^:]+):/g, 'if $1:\n    ')
      .replace(/else:/g, 'else:\n    ')
      .replace(/return\s+/g, 'return ')
      .replace(/print\s*\(/g, '\nprint(');
  }
  
  // Auto-detect JavaScript in triple backtick blocks without language specified
  if (text.includes('```\n') && !text.includes('```python') && !text.includes('```js') && !text.includes('```javascript')) {
    let looksLikeJS = strongJsKeywordsPattern.test(text);
    if (!looksLikeJS && jsKeywordsPattern.test(text) && !strongRustKeywordsPattern.test(text)) {
      // If general JS keywords (like let/const) are present, 
      // but strong JS keywords are not, and strong Rust keywords are also not present, then lean towards JS.
      looksLikeJS = true;
    }
    if (looksLikeJS) {
      // Replace generic code block with JavaScript code block
      return text.replace(/```\n/g, '```javascript\n');
    }
  }
  
  // If we detect JavaScript content but no language specified, add javascript tag
  if (!text.includes('```javascript') && !text.includes('```js') && 
      text.includes('```') && 
      (text.includes('function') || text.includes('const ') || 
       text.includes('let ') || text.includes('var '))) {
    let looksLikeJS = strongJsKeywordsPattern.test(text);
    if (!looksLikeJS && jsKeywordsPattern.test(text) && !strongRustKeywordsPattern.test(text)) {
      looksLikeJS = true;
    }
    if (looksLikeJS) {
      return text.replace(/```(?!\w)/g, '```javascript');
    }
  }
  
  // Format JavaScript bubble sort specifically if detected
  if ((text.includes('bubbleSort') || text.includes('bubble_sort')) && 
      text.includes('function') && !text.includes('\n')) {
    return text
      .replace(/```\n/g, '```javascript\n')
      .replace(/```/g, '```javascript\n')
      .replace(/function\s+bubbleSort/g, 'function bubbleSort')
      .replace(/\(([^)]*)\)\s*{/g, '($1) {\n  ')
      .replace(/const\s+/g, 'const ')
      .replace(/let\s+/g, 'let ')
      .replace(/for\s*\(/g, 'for (')
      .replace(/if\s*\(/g, 'if (')
      .replace(/}\s*else/g, '} else')
      .replace(/return\s+/g, 'return ')
      .replace(/;\s*(?=[a-zA-Z])/g, ';\n  ');
  }
  
  return text;
}

onMounted(() => {
  // Initial parsing of blocks on mount
  console.log("[CHATMSG-DEBUG] onMounted: Initial call to processMessage for message ID:", props.message.id);
  processMessage(); // Initial call
  
  // In case the message is raw code without formatting, try to apply preprocessing
  // This logic might be redundant if processMessage and extractCodeBlocks handle it well
  if (parsedBlocks.value.length === 1 && parsedBlocks.value[0].type === 'text') {
    const text = parsedBlocks.value[0].content;
    // Check for code-like patterns in raw text
    if (text && (
      text.includes('def ') || 
      text.includes('class ') || 
      text.includes('import ') ||
      text.includes('function ') ||
      text.includes('for ') && text.includes('range(')
    )) {
      // This looks like raw code, treat the entire text as a code block
      console.log("[CHATMSG-DEBUG] onMounted: Raw text detected, treating as code block.");
      parsedBlocks.value = [{
        type: 'code',
        language: text.includes('def ') || text.includes('import ') ? 'python' : 'javascript',
        content: text,
        isGenerating: false
      }];
    }
  }
});

// Watch for changes to the message
watch(() => props.message, (newMessage, oldMessage) => {
  if (window.enableStreamDebugLogging) sendDebugLogToServer({ 
      timestamp: new Date().toISOString(), 
      source: 'watch_props.message', 
      event: 'triggered', 
      details: { 
          messageId: newMessage.id, 
          newTextSnippet: newMessage.text ? newMessage.text.substring(0,30)+'...' : '(empty)', 
          newIsStreaming: newMessage.isStreaming,
          oldTextSnippet: oldMessage ? (oldMessage.text ? oldMessage.text.substring(0,30)+'...' : '(empty)') : '(no old msg)',
          oldIsStreaming: oldMessage?.isStreaming
      }
  });
  processMessage();
}, { deep: true });

// Watch for changes to the message text
watch(() => props.message.text, (newText, oldText) => {
  console.log(`[CHAT-MSG-COMPONENT] Message content updated:"${newText ? 'CONTENT' : 'EMPTY'}"Length:"${newText?.length || 0}"`);
  
  if (!newText && props.message.isStreaming) {
    parsedBlocks.value = [{ type: 'text', content: 'Waiting for response...' }];
    return;
  }
  
  // Force re-process of message content when text changes
  // This is critical for streaming updates to show correctly
  if (newText) {
    // Prioritize direct rendering for simple text (especially Chinese text)
    if (/[\u4e00-\u9fff]/.test(newText) || !newText.includes('```')) {
      parsedBlocks.value = [{
        type: 'text',
        content: newText
      }];
    } else {
      // For code blocks and more complex content
      processMessage();
    }
  }
}, { immediate: true });

});

// Get icon for annotation type
function getAnnotationIcon(type) {
  switch(type) {
    case 'info':
      return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`;
    case 'warning':
      return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>`;
    case 'error':
      return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`;
    case 'success':
      return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>`;
    default:
      return '';
  }
}

// Extract and display metadata if available
const metadata = computed(() => {
  if (!props.message.metadata) return null;
  
  try {
    // If metadata is a string, try to parse it as JSON
    if (typeof props.message.metadata === 'string') {
      return JSON.parse(props.message.metadata);
    }
    // If already an object, use it directly
    return props.message.metadata;
  } catch (e) {
    console.error('Error parsing metadata:', e);
    return null;
  }
});

// Function to format execution time nicely
function formatExecutionTime(ms) {
  if (ms < 1000) return `${ms}ms`;
  return `${(ms / 1000).toFixed(2)}s`;
}

// Check if there are any suggested questions to show
const hasSuggestions = computed(() => {
  return parsedBlocks.value.some(block => block.type === 'suggestion');
});

// Extract all suggestions for easier rendering
const suggestions = computed(() => {
  return parsedBlocks.value
    .filter(block => block.type === 'suggestion')
    .map(block => block.text);
});

// Add a computed property to derive processedParts from parsedBlocks
const processedParts = computed(() => {
  return parsedBlocks.value;
});

// Add a new method to detect Chinese text and choose the right API endpoint
function hasChineseText(text) {
  // Check if the message contains Chinese characters
  return /[\u4e00-\u9fff]/.test(text);
}

// Add a message at the beginning for Chinese text
function getInitialMessage(text) {
  if (hasChineseText(text)) {
    return {
      id: 'system-' + Date.now(),
      sender: 'system',
      text: '检测到中文输入。使用非流式生成以获得更好的响应。请耐心等待...\n(Chinese text detected. Using non-streaming generation for better response. Please be patient...)'
    };
  }
  return null;
}

// Copy code to clipboard
function copyCode(code) {
  if (!code) return;
  
  try {
    navigator.clipboard.writeText(code)
      .then(() => {
        // Find the index of this code block
        const index = parsedBlocks.value.findIndex(block => 
          block.type === 'code' && block.content === code
        );
        
        if (index !== -1) {
          // Set this block as copied
          copiedStates.value[index] = true;
          
          // Reset after 2 seconds
          setTimeout(() => {
            copiedStates.value[index] = false;
          }, 2000);
        }
      })
      .catch(err => {
        console.error('Failed to copy text: ', err);
      });
  } catch (err) {
    console.error('Error copying code:', err);
  }
}

// Helper function to extract only complete code blocks from text
// without closing unclosed blocks (for use with partial streaming)
function extractCompleteBlocks(text) {
  if (!text || !text.trim()) return [];
  
  const result = [];
  let lastIndex = 0;
  
  // Process complete code blocks only
  // Only matches fully formed code blocks with opening and closing ```
  const completeBlockRegex = /```([\w#+-]*)\n?([\s\S]*?)```/g;
  let match;
  
  while ((match = completeBlockRegex.exec(text)) !== null) {
    // Add any text before this code block
    if (match.index > lastIndex) {
      result.push({
        type: 'text',
        content: text.substring(lastIndex, match.index)
      });
    }
    
    // Add the complete code block
    result.push({
      type: 'code',
      language: match[1] || 'plaintext',
      content: match[2].trim(),
      isGenerating: false // This is a complete block
    });
    
    lastIndex = match.index + match[0].length;
  }
  
  // Add any remaining text after the last complete code block
  if (lastIndex < text.length) {
    result.push({
      type: 'text',
      content: text.substring(lastIndex)
    });
  }
  
  return result;
}

// Watch for changes to the message content to debug reactivity issues
watch(() => props.message.text, (newText, oldText) => {
  if (newText !== oldText) {
    console.log('[CHAT-MSG-COMPONENT] Message content updated:', 
      newText ? 
        (newText.length > 30 ? newText.substring(0, 30) + '...' : newText) 
        : 'EMPTY',
      'Length:', newText?.length || 0);
    
    // Force re-parsing of content
    parseMessageContent();
  }
}, { immediate: true });

// Function to parse the message content and handle code blocks
function parseMessageContent() {
  if (!props.message.text) {
    console.log('[CHAT-MSG-PARSE] Empty message text, clearing blocks');
    parsedBlocks.value = [];
    return;
  }
  
  try {
    console.log('[CHAT-MSG-PARSE] Parsing message content, length:', props.message.text.length);
    
    // For Chinese text or simple messages, shortcut to simple rendering
    if (/[\u4e00-\u9fff]/.test(props.message.text) || !props.message.text.includes('```')) {
      console.log('[CHAT-MSG-PARSE] Using direct text rendering for simple or Chinese text');
      parsedBlocks.value = [{
        type: 'text',
        content: props.message.text
      }];
      return;
    }
    
    // Extract code blocks from the text for more complex messages
    parsedBlocks.value = extractCodeBlocks(props.message.text);
    console.log('[CHAT-MSG-PARSE] Parsed blocks count:', parsedBlocks.value.length);
  } catch (err) {
    console.error('[CHAT-MSG-PARSE] Error parsing message:', err);
    // Fallback to simple text display
    parsedBlocks.value = [{
      type: 'text',
      content: props.message.text
    }];
  }
}
</script>

<template>
  <div class="chat-message" :class="[
    `chat-message-${message.sender}`,
    { 'chat-message-thinking': isThinking },
    { 'message-error': message.isError }
  ]">
    <div class="avatar" :class="{ 'avatar-thinking': isThinking }">
      <!-- Show different icons based on message type -->
      <span v-if="message.isError">⚠️</span>
      <span v-else>{{ message.sender === 'user' ? '👤' : '🤖' }}</span>
    </div>
    
    <div class="message-content-wrapper">
      <div class="message-header">
        <div class="sender-label">
          <!-- Show "Error" for error messages -->
          <span v-if="message.isError">Error</span>
          <span v-else>{{ message.sender === 'user' ? 'You' : 'Agent' }}</span>
        </div>
        <div class="message-actions">
          <button 
            v-if="message.text && message.text.length > 0 && !isThinking" 
            class="copy-button" 
            @click="$emit('copy', message.text)"
            title="Copy message"
          >
            📋
          </button>
        </div>
      </div>
      
      <div :class="['message-content', { 
        'thinking': isThinking,
        'streaming': message.isStreaming && !isThinking 
      }]">
        <!-- Only show thinking indicator when there's no content -->
        <div v-if="isThinking && (!message.text || message.text === '')" class="thinking-indicator">
          <span>Thinking</span>
          <span class="thinking-dots"><span>.</span><span>.</span><span>.</span></span>
        </div>
        
        <!-- Show streaming indicator when content is streaming in -->
        <div v-if="message.isStreaming && message.text && !isThinking" class="streaming-indicator">
          <span class="stream-pulse"></span>
        </div>
        
        <!-- Prioritize simple content rendering for better reliability -->
        <div v-else-if="message.text && (!message.text.includes('```') || /[\u4e00-\u9fff]/.test(message.text))" 
             v-html="formatText(message.text)"
             :class="{'streaming-text': message.isStreaming}"></div>
        
        <!-- Handle content with code blocks only when necessary -->
        <div v-else-if="message.text && parsedBlocks.length > 0">
          <div v-for="(part, index) in parsedBlocks" :key="index">
            <div v-if="part.type === 'text'" 
                 v-html="formatText(part.content)"
                 :class="{'streaming-text': part.isStreaming || message.isStreaming}"></div>
            <div v-else-if="part.type === 'code'" 
                 class="code-highlight-wrapper" 
                 :class="[
                   `language-${part.language}`, 
                   { 'generating': part.isGenerating },
                   { 'streaming': part.isStreaming || message.isStreaming }
                 ]">
              <div class="code-header">
                <span class="language-label">{{ part.language }}</span>
                <button v-if="!part.isGenerating && !message.isStreaming" class="copy-button" @click="copyCode(part.content)" :data-copied="copiedStates[index]">
                  <span class="copy-text">{{ copiedStates[index] ? 'Copied!' : 'Copy' }}</span>
                </button>
                <span v-else-if="part.isGenerating" class="generating-badge">
                  <span>Generating</span>
                  <span class="thinking-dots"><span>.</span><span>.</span><span>.</span></span>
                </span>
                <span v-else-if="message.isStreaming" class="streaming-badge">
                  <span>Streaming</span>
                  <span class="thinking-dots"><span>.</span><span>.</span><span>.</span></span>
                </span>
              </div>
              <pre><code v-html="getHighlightedCodeHtml(part.content, part.language)"></code></pre>
            </div>
          </div>
        </div>
        
        <!-- Fallback for any case we missed -->
        <div v-else-if="message.text" 
             v-html="formatText(message.text)"
             :class="{'streaming-text': message.isStreaming}"></div>
      </div>
    </div>
  </div>
</template>

<style scoped>
.chat-message {
  display: flex;
  margin-bottom: 15px;
  max-width: 85%;
  position: relative;
  animation: fadeIn 0.3s ease;
}

.chat-message-user {
  align-self: flex-end;
  flex-direction: row-reverse;
  max-width: 80%;
}

.chat-message-thinking {
  max-width: 60%;
}

.avatar {
  font-size: 1.5em;
  margin-right: 10px;
  margin-top: 5px;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  flex-shrink: 0;
}

.avatar-thinking {
  opacity: 0.6;
}

.chat-message-user .avatar {
  margin-right: 0;
  margin-left: 10px;
}

.message-content {
  background-color: white;
  padding: 12px 16px;
  border-radius: 18px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.05);
  position: relative;
  max-width: 100%;
  width: 100%;
}

.message-content-thinking {
  background-color: #f3f4f6;
  box-shadow: 0 1px 3px rgba(0,0,0,0.03);
}

.chat-message-user .message-content {
  background-color: #4a6bff;
  color: white;
  border-bottom-right-radius: 5px;
}

.chat-message-agent .message-content {
  background-color: white;
  border-bottom-left-radius: 5px;
}

.sender {
  font-weight: 600;
  margin-bottom: 5px;
  display: block;
  font-size: 0.9em;
}

.chat-message-user .sender {
  color: rgba(255, 255, 255, 0.9);
}

.message-blocks {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.text-block {
  line-height: 1.5;
  font-size: 1em;
  overflow-wrap: break-word;
  word-wrap: break-word;
  word-break: break-word;
}

.thinking-text {
  opacity: 0.7;
  font-style: italic;
}

.inline-code {
  background-color: rgba(0,0,0,0.06);
  padding: 2px 5px;
  border-radius: 4px;
  font-family: 'Consolas', 'Monaco', monospace;
  font-size: 0.9em;
  color: #e83e8c;
  white-space: nowrap;
}

/* Style for user message inline code */
.chat-message-user .inline-code {
  background-color: rgba(255,255,255,0.2);
  color: white;
}

/* Markdown list styles */
.markdown-list {
  margin: 8px 0;
  padding-left: 20px;
}

.markdown-list li {
  margin-bottom: 6px;
}

.chat-message-user .markdown-list li {
  color: white;
}

/* Image block styles */
.image-block {
  margin: 10px 0;
  max-width: 100%;
}

.image-block img {
  max-width: 100%;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.2s;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  display: block;
}

.image-block img:hover {
  transform: scale(1.01);
}

.image-caption {
  margin-top: 6px;
  font-size: 0.9em;
  color: #666;
  text-align: center;
}

/* Suggestion/follow-up questions styles */
.suggestions-container {
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid #eaeaea;
}

.suggestions-title {
  font-size: 0.9em;
  color: #666;
  margin-bottom: 8px;
}

.suggestions-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.suggestion-button {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background-color: #f0f2ff;
  color: #4a6bff;
  border: 1px solid #dce0ff;
  border-radius: 16px;
  padding: 6px 12px;
  font-size: 0.9em;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-top: 4px;
}

.suggestion-button:hover {
  background-color: #e6eaff;
  transform: translateY(-1px);
}

.suggestion-button:active {
  transform: translateY(0);
}

/* Action button styles */
.action-button {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background-color: #4a6bff;
  color: white;
  border: none;
  border-radius: 6px;
  padding: 8px 16px;
  font-size: 0.9em;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(74, 107, 255, 0.2);
  margin-top: 4px;
}

.action-button:hover {
  background-color: #3a5bf0;
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(74, 107, 255, 0.3);
}

.action-button:active {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(74, 107, 255, 0.2);
}

/* Annotation block styles */
.annotation-block {
  padding: 12px 16px;
  border-radius: 8px;
  margin: 10px 0;
}

.annotation-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
  font-weight: 600;
}

.annotation-icon {
  display: flex;
  align-items: center;
}

.annotation-content {
  margin-left: 28px;
}

.annotation-info {
  background-color: #e6f7ff;
  border-left: 4px solid #1890ff;
}

.annotation-warning {
  background-color: #fffbe6;
  border-left: 4px solid #faad14;
}

.annotation-error {
  background-color: #fff2f0;
  border-left: 4px solid #ff4d4f;
}

.annotation-success {
  background-color: #f6ffed;
  border-left: 4px solid #52c41a;
}

/* Metadata styles */
.message-metadata {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 12px;
  padding-top: 8px;
  border-top: 1px dashed #eaeaea;
}

.metadata-item {
  font-size: 0.8em;
  color: #666;
  display: flex;
  align-items: center;
  gap: 4px;
  background-color: #f6f6f6;
  padding: 3px 8px;
  border-radius: 12px;
}

.metadata-icon {
  font-size: 1.1em;
}

/* Thinking indicator */
.thinking-indicator {
  display: flex;
  align-items: center;
  padding: 6px 0;
}

.thinking-dots {
  display: flex;
  align-items: center;
  gap: 4px;
}

.thinking-dots span {
  height: 8px;
  width: 8px;
  background-color: #6169e6;
  border-radius: 50%;
  display: inline-block;
  animation: pulse 1.4s infinite ease-in-out;
}

.thinking-dots span:nth-child(2) {
  animation-delay: 0.2s;
}

.thinking-dots span:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes pulse {
  0%, 100% {
    transform: scale(0.6);
    opacity: 0.6;
  }
  50% {
    transform: scale(1);
    opacity: 1;
  }
}

/* Debug indicator for development */
.debug-indicator {
  position: absolute;
  top: -8px;
  right: 10px;
  background-color: rgba(255, 0, 0, 0.1);
  color: red;
  padding: 2px 4px;
  border-radius: 4px;
  font-size: 10px;
  z-index: 10;
  display: none; /* Hide in production */
}

/* Only show in development mode */
.chat-message:hover .debug-indicator {
  display: block;
}

/* Main styling for code language sections */
.code-highlight-wrapper {
  margin: 15px 0;
  background-color: #282c34;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  border-left: 4px solid #3b82f6;
}

/* Language-specific left border colors */
.code-highlight-wrapper.language-python {
  border-left-color: #3572A5;
}

.code-highlight-wrapper.language-javascript, 
.code-highlight-wrapper.language-js {
  border-left-color: #f7df1e;
}

.code-highlight-wrapper.language-c {
  border-left-color: #0078C1;
}

.code-highlight-wrapper.language-cpp {
  border-left-color: #6295CB;
}

.code-highlight-wrapper.language-go,
.code-highlight-wrapper.language-golang {
  border-left-color: #29BEB0;
}

.code-highlight-wrapper.language-rust {
  border-left-color: #DE3F1C;
}

.code-highlight-wrapper.language-typescript,
.code-highlight-wrapper.language-ts {
  border-left-color: #3178c6;
}

.code-highlight-wrapper.language-bash,
.code-highlight-wrapper.language-shell,
.code-highlight-wrapper.language-sh,
.code-highlight-wrapper.language-zsh,
.code-highlight-wrapper.language-terminal {
  border-left-color: #4EAA25;
}

.code-highlight-wrapper.language-toml {
  border-left-color: #9c4221;
}

.code-highlight-wrapper.language-xml,
.code-highlight-wrapper.language-markup {
  border-left-color: #e34c26;
}

.code-highlight-wrapper.language-yaml,
.code-highlight-wrapper.language-yml {
  border-left-color: #cb171e;
}

.code-highlight-wrapper.language-json {
  border-left-color: #5b9bd5;
}

.code-highlight-wrapper.generating {
  border-left-color: #f59e0b;
}

.code-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #21252b;
  padding: 8px 12px;
  color: #abb2bf;
  font-family: 'Consolas', 'Monaco', monospace;
  font-size: 0.85em;
  border-bottom: 1px solid #333;
}

.language-label {
  text-transform: lowercase;
  font-weight: 500;
}

.generating-badge {
  display: flex;
  align-items: center;
  gap: 6px;
  color: #f59e0b;
  animation: pulse 1.5s infinite;
  font-size: 0.85em;
}

.code-highlight-wrapper pre {
  margin: 0;
  background-color: #282c34;
  padding: 1em;
  border-radius: 0;
  overflow-x: auto;
}

.generating-placeholder {
  opacity: 0.7;
}

.copy-button {
  display: flex;
  align-items: center;
  gap: 5px;
  background-color: rgba(255,255,255,0.1);
  color: #abb2bf;
  border: none;
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 0.9em;
  cursor: pointer;
  transition: all 0.2s;
}

.copy-button:hover {
  background-color: rgba(255,255,255,0.2);
}

.copy-button[data-copied="true"] {
  background-color: rgba(34, 197, 94, 0.2);
}

.copy-button[data-copied="true"] .copy-text {
  color: #22c55e;
}

@keyframes pulse {
  0%, 100% {
    opacity: 0.7;
  }
  50% {
    opacity: 1;
  }
}

/* Add styling for error messages */
.message-error {
  background-color: #ffebee;
  border-left: 4px solid #f44336;
  padding: 10px;
  margin: 10px 0;
  border-radius: 4px;
}

.message-error .message-content {
  color: #d32f2f;
  font-weight: 500;
}

.message-error .error-icon {
  margin-right: 10px;
  color: #f44336;
}

.chat-message.message-error {
  background-color: #ffebee;
  border-left: 4px solid #f44336;
}

.chat-message.message-error .message-content {
  color: #d32f2f;
  font-weight: 500;
}

.chat-message-agent {
  background-color: #f5f5f5;
  border-left: 3px solid #2196f3;
}

/* Add streaming styles */
.streaming-indicator {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  align-items: center;
  z-index: 2;
}

.stream-pulse {
  width: 8px;
  height: 8px;
  background-color: #4CAF50;
  border-radius: 50%;
  margin-left: 5px;
  animation: pulse 1.5s infinite;
}

.streaming-text {
  animation: streaming-effect 1.5s ease-in-out infinite;
  border-right: 2px solid #4CAF50;
  padding-right: 5px;
  position: relative;
}

/* Add a subtle background highlight to streaming text */
.streaming-text::after {
  content: '';
  position: absolute;
  right: 0;
  top: 0;
  height: 100%;
  width: 15px;
  background: linear-gradient(to left, rgba(76, 175, 80, 0.1), transparent);
  animation: streaming-bg 1.5s ease-in-out infinite;
}

.message-content.streaming {
  border-left: 3px solid #4CAF50;
  /* Add a subtle background pulse to highlight that content is streaming */
  background: linear-gradient(to right, white, rgba(76, 175, 80, 0.05), white);
  background-size: 200% 100%;
  animation: streaming-bg-pulse 3s ease-in-out infinite;
}

.code-highlight-wrapper.streaming {
  border-left-color: #4CAF50 !important;
}

.streaming-badge {
  display: flex;
  align-items: center;
  gap: 6px;
  color: #4CAF50;
  animation: pulse 1.5s infinite;
  font-size: 0.85em;
}

@keyframes streaming-effect {
  0%, 100% {
    border-right-color: rgba(76, 175, 80, 0.5);
  }
  50% {
    border-right-color: rgba(76, 175, 80, 1);
  }
}

@keyframes streaming-bg {
  0%, 100% {
    opacity: 0.3;
  }
  50% {
    opacity: 0.8;
  }
}

@keyframes streaming-bg-pulse {
  0%, 100% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
}
</style> 